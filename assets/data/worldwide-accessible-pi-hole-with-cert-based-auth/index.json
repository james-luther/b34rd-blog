{"hash":"92a90b9266085ce96d20d6cef9819ea072252d0c","data":{"post":{"title":"Worldwide Accessible Pi-Hole With Cert Based Auth!","path":"/worldwide-accessible-pi-hole-with-cert-based-auth/","slug":"worldwide-accessible-pi","datetime":"2020-03-29 00:00:00","content":"<p>Ok, ok, I know it sounds crazy! But please, hear me out on this one. What we are going to do is take a Pi 4, install Raspbian Lite, PiHole, Squid, Webmin, and AutoSSH. With these things and a free instance in Google Cloud Platform we can have some fun!</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*BJk1CHSD9-Sc8R0FjG2hYg.png\" alt=\"alt text\" title=\"Pi-Hole\"></p>\n<hr>\n<h3 id=\"hardware-and-initial-setup\"><a href=\"#hardware-and-initial-setup\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"#header-3\"></a>Hardware and Initial Setup</h3>\n<p>First things first, we need to gather up the hardware we need. I’m using a Raspberry Pi 4 to get the true gigabit connection but this will work on all models with a few different tweaks. Other than the Pi, we need ethernet cable, micro sdcard, power connector, and case/accessories of your choice. We also need an internet connected computer to download Raspbian Lite.</p>\n<p>Now that we have all of our stuff. Let’s get started with downloading. Head over to <a href=\"https://www.raspberrypi.org/downloads/raspbian/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.raspberrypi.org/downloads/raspbian/</a> and download Raspbian Buster Lite (or the most recent one if something is newer)</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*Rchwe29P3ksSH5EYMMPJvg.png\" alt=\"alt text\" title=\"This is what we are looking for\"></p>\n<p>Once this is downloaded we need to copy it over to our sdcard. There are a few ways to do this and the amazing people over at raspberrypi.org wrote excellent directions based on whichever operating system you are using. Once the copy is completed we need to add one thing to our boot partition. Create an empty file and name it “SSH”. This will enable ssh on first boot and you can use the Pi completely headless.</p>\n<p>Now that we have this all done, connect directly to your main switch/router/connection to the outside world and power on.</p>\n<p>After a bit of time you can check your DHCP server for what IP address your device was allocated. We can then ssh over with</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ ssh pi@ip_address</span></span></code></pre>\n<p>Once we are logged in there are a few things I recommend doing before proceeding.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo raspi-config</span></span></code></pre>\n<p>Ensure locale and any other specific things you want are configured. Also we need to go into advanced settings and allocate less memory for GPU to ensure our little device has the most RAM it can have to accomplish tasks. I am using 16 on my Pi4 but on lower models I suggest 8.</p>\n<p>Next we need to do the obligatory</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt-get -y dist-upgrade</span></span></code></pre>\n<p>This will ensure we are all up -to-date before we begin.</p>\n<p>Still with me? If so, awesome, if not, well, you’re not reading so it doesn’t matter. From here I’m going to install pre-requisites for pihole, webadmin, and squid. I am going to be running squid as a web caching proxy, pihole to block all the ads, and webadmin to manage the pi remotely from a browser. I will list which items are for which so you can exclude items if you don’t want the services.</p>\n<hr>\n<h3 id=\"pi-hole\"><a href=\"#pi-hole\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"#header-3\"></a>Pi-Hole</h3>\n<p><img src=\"https://miro.medium.com/max/1098/1*yGEV1VBZD_lQ_oU8oXZ1cw.png\" alt=\"alt text\" title=\"Pi-Hole Logo\"></p>\n<p>First, let’s begin with Pi-Hole!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get -y install git\n$ git clone --depth 1 https://github.com/pi-hole/pi-hole.git Pi-hole\n$ cd &quot;Pi-hole/automated install/&quot;\n$ sudo bash basic-install.sh</span></span></code></pre>\n<p>The installation for Pi-hole is very straight forward. Follow the on-screen prompts, answer questions, and you are good to go. Once we have this setup and configured how we want there are a couple changes we need to make.</p>\n<p>First, I’m going to modify lighttpd to only listen on localhost.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*wa7kMq5LgO5mHWw7aaGBuA.png\" alt=\"alt text\" title=\"Lighttpd Directory\"></p>\n<p>To do this we need to do the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vi /etc/lighttpd/external.conf</span></span></code></pre>\n<p>From here we just add the line:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">server.bind=&quot;127.0.0.1&quot;</span></span></code></pre>\n<p>Save the file and restart the service.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl restart lighttpd.service</span></span></code></pre>\n<p>We aren’t finished. If you notice, this will not allow you to access your device through a proxy. To remedy this problem we need to edit another file.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vi /var/www/html/pihole/index.html</span></span></code></pre>\n<p>We need to change line 10 to match the following</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$serverName = htmlspecialchars($_SERVER[&quot;SERVER_ADDR&quot;]);</span></span></code></pre>\n<p>We also need to edit auth.php</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vi /var/www/html/admin/scripts/pi-hole/php/auth.php</span></span></code></pre>\n<p>Under the following section you MAY need to add your FQDN to ensure all configuration changes, logins, etc through the proxy function. You can test as needed.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$AUTHORIZED_HOSTNAMES = array(\n        $ipv4,\n        $ipv6,\n        str_replace(array(&quot;[&quot;,&quot;]&quot;), array(&quot;&quot;,&quot;&quot;), $_SERVER[&quot;SERVER_NAME&quot;]),\n        &quot;pi.hole&quot;,\n        &quot;localhost&quot;\n    );</span></span></code></pre>\n<p>For me, I needed to ensure localhost was listed since we are using localhost to access the server through the proxy.</p>\n<p>We are now able to access the dashboard through a proxy. If this is all you want to implement, skip ahead to the Google Cloud configuration and the AutoSSH configuration. For now, I’m going ahead into squid and webmin.</p>\n<hr>\n<h3 id=\"squid\"><a href=\"#squid\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"#header-3\"></a>Squid</h3>\n<p><img src=\"https://miro.medium.com/max/1400/1*8JCkAUbkUcaMWCXnUgzJrA.png\" alt=\"alt text\" title=\"Squid\"></p>\n<p>Squid is a web cache proxy. I LOVE it! Anyway, how I configure it works really well for me, you can honestly adjust everything as you like.</p>\n<p>To begin we need to install squid and all the parts of it we will be using later.</p>\n<p>Since we have Pi-Hole installed we don’t need to worry about a static ip address. If you are only here for squid, well, USE STATIC IP!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get -y install squid squid-cgi calamaris squidclient</span></span></code></pre>\n<p>This will require some additional packages but they will be installed with these.</p>\n<p><strong> I’m using squid-cgi to view data via webmin. If you don’t wish to use webmin you can just go with squidclient and monitor via command line*</strong></p>\n<p>Let’s get to configuring our proxy!</p>\n<p>Best thing to do at the start is backing up the default configuration in case we mess up everything.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo cp /etc/squid/squid.conf /etc/squid/squidoriginal.conf.bak</span></span></code></pre>\n<p>Now we need to edit the config. Here there are only a few options to enable/change. I prefer vim if you haven’t noticed from previous things or even my usage here. To search you just use a ‘/’. If you prefer nano you need to use ‘ctrl’ + ‘w’. Either way find the sections and edit/add lines as needed. Most of these are editing current ones minus the acl ones.</p>\n<p>First thing first! ACL! Most private CIDR address spaces are covered. I recommend commenting all of these out and adding your own to reflect your network. Mine is:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">acl localnet 192.168.2.0/24</span></span></code></pre>\n<p>Ensure we have the acl allowed</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">http_access allow localnet</span></span></code></pre>\n<p>Now adjust dns</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">Find: # dns_v4_first off remove the # symbol and change off to on.</span></span></code></pre>\n<p>The remaining changes I’m making are as follows:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">Cache_mem 256\nMBMaximum_object_size 4096\nMBMaximum_object_size_in_memory 8192\nKBCache_dir ufs /var/spool/squid = 8192 </span></span></code></pre>\n<p>Now we save and exit. Then we backup this configuration just to be safe.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo cp /etc/squid/squid.conf /etc/squid/mysquid.conf.bak</span></span></code></pre>\n<p>After this we can start our proxy</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl start squid</span></span></code></pre>\n<p>Squid is now up and running! From here I’m going to configure webmin to manage this as well the rest of my pi remotely. You can leave it here or continue along.</p>\n<hr>\n<h3 id=\"webmin\"><a href=\"#webmin\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a><a href=\"#header-3\"></a>Webmin</h3>\n<p><img src=\"https://miro.medium.com/max/1400/1*Uj85QkRucFxt7k_W5u3PRw.png\" alt=\"alt text\" title=\"Webmin\"></p>\n<p>So.. personally, I’m not the biggest fan of this software. I think it is a lot of overkill for what we need. It does however make things very easy. We are going to cheat in installing this a bit. It seems odd but trust me, it makes our life easier.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ cd ~ \n$ mkdir webmin-download\n$ cd webmin-download\n$ wget http://www.webmin.com/download/deb/webmin-current.deb\n$ sudo dpkg -i webmin-current.deb </span></span></code></pre>\n<p>This is going to error saying we are missing dependencies. That’s perfect. We want that to happen. Now we can go ahead and install dependencies and webmin with the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get -f install</span></span></code></pre>\n<p>Now webmin is all installed as well as our required packages. Simple right?!</p>\n<p>We do have some configuration to do here to allow us to manage squid from webmin as well as make it only listen on localhost.</p>\n<p>Let’s browse over to our Pi and open the webmin page.</p>\n<p><a href=\"https://IP_OF_PI:10000\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://IP_OF_PI:10000</a></p>\n<p>The login will be username and password of your pi. By default this is pi:raspberry.</p>\n<p>Next we need to go to the left and find squid under unused modules section. In here we need to adjust the paths to everything and adjust the startup, stop, and restart script sections.</p>\n<p><img src=\"https://miro.medium.com/max/1352/0*wpLGTjxNhDKryMUL\" alt=\"alt text\" title=\"Squid Config\"></p>\n<p>The highlighted sections you will need to make match your install. For my install I had to change all from squid3 to squid and the scripts all to the corresponding systemctl ones. For example:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">service start squid</span></span></code></pre>\n<p>changes to</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">systemctl start squid</span></span></code></pre>\n<p>I’m confident you can change the rest. Depending on webmin version you will have some additional prompts to change. I had none.</p>\n<p>We can now manage our squid server via webmin and add more things as well as adjust ssh settings, monitor pi, and all sorts of fun little things. From here we are going to make some additional adjustments for our installation to only listen locally and work through a proxy server.</p>\n<p>The MOST important thing is to adjust access controls.</p>\n<p>In here we want to go to proxy restrictions tab and ensure manager is not denied. If so, we will not be able to access settings once we connect to our proxy server.</p>\n<p>This is what mine looks like:</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*uMKELXgysR3CI5HI8Hf8RQ.png\" alt=\"alt text\" title=\"My configuration\"></p>\n<p>From here we are going to go into webmin configuration. Look to the left pane and click webmin section and select webmin configuration.</p>\n<p>In this section we will be disabling SSL. The other options are easier to do in the config file itself. We can actually do all of these changed in config files but selecting a radio button I find easier than searching for a line in a config file and editing.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*qOJwwSC0sbDQmDvdCGbuIw.png\" alt=\"alt text\" title=\"Webmin Configuration\"></p>\n<p>Select SSL Encryption and under Enable SSL? select NO</p>\n<p>Yes, I know this seems like a bad idea, but don’t worry. We are going to handle our own SSL later.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*weVJ_MGv0IaOOUWMYtbGaA.png\" alt=\"alt text\" title=\"SSL Configuration\"></p>\n<p>Save settings and we are now going to ssh into our pi. From here we will execute the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ cd /etc/webmin\n$ ls </span></span></code></pre>\n<p><img src=\"https://miro.medium.com/max/1400/1*hAoFAzZWZ9tO0iuP6rtozA.png\" alt=\"alt text\" title=\"Webmin Folder\"></p>\n<p>We need to edit the file called config and add some lines to the bottom.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vi config</span></span></code></pre>\n<p>We will then add the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">referer_none=1\nreferer=1\nreferers=127.0.0.1</span></span></code></pre>\n<p>Once this is done, save file and exit. Now restart webmin</p>\n<p><img src=\"https://miro.medium.com/max/772/1*lo29kgQGz0CARUpbVkYnSg.png\" alt=\"alt text\" title=\"Webmin Config File\"></p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl restart webmin</span></span></code></pre>\n<p>We will now only be able to access our webmin page via proxy.</p>\n<hr>\n<p>Time to get started with SSL. We are going to setup our own CA here and generate some user certificates. I know this guide is a bit long but this part ensures all ourinternet accessible stuff is as secure as possible.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*Y_6jv8KwO4Dny4r3MxNpig.png\" alt=\"alt text\" title=\"OpenSSL\"></p>\n<p>I HIGHLY recommend you put your CA on a non-internet connected device. If you must put it on something that is connected, ensure you secure things. If your CA is compromised your organization is compromised. The guide I’m giving is on Linux using OpenSSL. There are a lot of things that are up to personal preference and you can adjust as you see fit.</p>\n<p>You can do all of this in whatever directory you choose. I’m just working in /root and will be giving a very quick setup. First we need to create our openssl.conf. Mine looks like this:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">[ ca ]\ndefault_ca = CA_default                 # The name of the CA configuration to be used.\n                                        # can be anything that makes sense to you.\n[ CA_default ]\ndir = /etc/ssl/ca                       # Directory where everything is kept\ncerts = $dir/certs                      # Directory where the issued certs are kept\ncrl_dir = $dir/crl                      # Directory where the issued crl are kept\ndatabase = $dir/index.txt               # database index file.\n#unique_subject = no                    # Set to &#39;no&#39; to allow creation of\n                                        # several certificates with same subject.\nnew_certs_dir = $dir/certs              # Default directory for new certs.\n\ncertificate = $dir/ca.crt               # The CA certificate\nserial = $dir/serial                    # The current serial number\ncrlnumber = $dir/crlnumber              # The current crl number\n                                        # must be commented out to leave a V1 CRL\ncrl = $dir/crl.pem                      # The current CRL\nprivate_key = $dir/private/ca.key       # The private key\nRANDFILE    = $dir/private/.rand        # private random number file\n\nx509_extensions = usr_cert              # The extentions to add to the cert\n\nname_opt = ca_default                   # Subject Name options\ncert_opt = ca_default                   # Certificate field options\n\ndefault_days     = 365                   # how long to certify for\ndefault_crl_days = 30                    # how long before next CRL\ndefault_md       = sha1                  # use public key default MD\npreserve         = no                    # keep passed DN ordering\n\npolicy = policy_match</span></span></code></pre>\n<p>You obviously will want to adjust things as needed here for your configuration. Now I’m going to create some files. Again, I’m logged in as root.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">mkdir -p /etc/ssl/ca/certs/users &amp;&amp; \\\nmkdir /etc/ssl/ca/crl &amp;&amp; \\\nmkdir /etc/ssl/ca/private</span></span></code></pre>\n<p>Next, we’ll create the reference files for the configuration. The database index file can be created empty. The CRL number file, on the other hand, will be expected by OpenSSL to have the first number in it:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">touch /etc/ssl/ca/index.txt &amp;&amp; echo ’01’ &gt; /etc/ssl/ca/crlnumber</span></span></code></pre>\n<p>Finally, we’ll create our server certificates and the certificate revocation list for the CA. We’ll set an expiration of one year in our example. Again, you can set this up however you like based on your environment.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">openssl genrsa -des3 -out /etc/ssl/ca/private/ca.key 4096\n\nopenssl req -new -x509 -days 1095 \\\n    -key /etc/ssl/ca/private/ca.key \\\n    -out /etc/ssl/ca/certs/ca.crt\n\nopenssl ca -name CA_default -gencrl \\\n    -keyfile /etc/ssl/ca/private/ca.key \\\n    -cert /etc/ssl/ca/certs/ca.crt \\\n    -out /etc/ssl/ca/private/ca.crl \\\n    -crldays 1095</span></span></code></pre>\n<p>Whew! We got that done. Now to get to generating user certificates.</p>\n<p>All we need to do is the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">openssl genrsa -des3 -out /etc/ssl/ca/certs/users/USERNAME.key 1024\n\nopenssl req -new -key /etc/ssl/ca/certs/users/USERNAME.key \\\n    -out /etc/ssl/ca/certs/users/USERNAME.csr\n\nopenssl x509 -req -days 1095 \\\n    -in /etc/ssl/ca/certs/users/USERNAME.csr \\\n    -CA /etc/ssl/ca/certs/ca.crt \\\n    -CAkey /etc/ssl/ca/private/ca.key \\\n    -CAserial /etc/ssl/ca/serial \\\n    -CAcreateserial \\\n    -out /etc/ssl/ca/certs/users/USERNAME.crt\n\nopenssl pkcs12 -export -clcerts \\\n    -in /etc/ssl/ca/certs/users/USERNAME.crt \\\n    -inkey /etc/ssl/ca/certs/users/USERNAME.key \\\n    -out /etc/ssl/ca/certs/users/USERNAME.p12</span></span></code></pre>\n<p>Obviously adjust names, paths, etc based on what you are doing. If everything was configured correctly, we are 100% good to go!! Remember based on OpenSSL versions, Linux distribution, etc your experience may vary. This is only a rough guide on how to do this.</p>\n<hr>\n<p>To the cloud!!</p>\n<p><img src=\"https://miro.medium.com/max/556/1*pU5dtthop4tgAISuR742EQ.png\" alt=\"alt text\" title=\"Google Cloud\"></p>\n<p>You can use any cloud platform or even a server with static IP address for this part if you choose. I’m going with Google Cloud Platform because, well, there is a free tier that is perfect for this type of thing. This is going to be a guide on setting up your instance, installing nginx, configuring nginx, and setting up SSL. We will need some things from our CA in a bit.\nGoogle Cloud Platform\nGoogle Cloud Platform lets you build, deploy, and scale applications, websites, and services on the same infrastructure…\nconsole.cloud.google.com</p>\n<p>Here you will need a Google account. If you are averse to Google, I apologize. Once here, you will need to setup billing. What we are doing is in the free tier so you won’t be charged BUT you need to have billing configured to allow creation of the things we are doing. Once your cloud billing and account is all setup we can begin.</p>\n<p>We need to create a new project. Once you have your project created we need to click on compute engine in the left side menu.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*8EJg7W36vN2YyXFqqe5R6A.png\" alt=\"alt text\" title=\"Compute Engine\"></p>\n<p>Don’t worry about the submenu. We are just going to Compute Engine section. On the top of this page we need to select Create Instance</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*SeeRpVBn66aLtXA0WWsHFw.png\" alt=\"alt text\" title=\"Create Instance\"></p>\n<p>You will be greeted by a page that looks something like this:</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*rVm8miIjyxMmfLcwbauNTQ.png\" alt=\"alt text\" title=\"New Instance\"></p>\n<p>Ignore the price and everything for now. We are going to make a bunch of selections and the price will still say something when finished. Every account though is allowed one micro instance for free.</p>\n<p>Things to setup. First, we must name our instance. Next we need to change Machine type to f1-micro. There should be one option. This will make changes to region, zone, and boot disk. You can make adjustments to all of these as you see fit but ensure you are in us-central region and the machine type stays f1-micro. If those change you will be billed for your virtual machine.</p>\n<p>Once options are selected go ahead and create your instance and wait for it to finish.</p>\n<p>During this time, if you are familiar with Google Cloud Platform you can change settings to meet your needs, if you aren’t, I recommend using this time to just browse through your options and read up on what the free tier includes. There is A LOT of things you can do.</p>\n<p>Once our instance is complete we just click the SSH icon next to it. Your screen should look something like this:</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*8cW9tzFMaFHhJKNiPI-f-g.png\" alt=\"alt text\" title=\"Our Instance\"></p>\n<p>If you added any extra keys or anything they are being copied over. Once we are logged in we need to do our usual house items such as updates and installation of packages.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt-get -y dist-upgrade$ sudo apt-get install nginx certbot</span></span></code></pre>\n<p>From here I recommend setting up ssh keys. You can generate them on your cloud instance or on your pi and copy them over. You just need to run</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ ssh-keygen</span></span></code></pre>\n<p>And follow the on screen prompts. Your pi and cloud instance will need to share a key in order to perform ssh port forwarding we are going to setup. From here we need the key shared with our pi and added into the Cloud Console. If you don’t add to the Google Cloud platform the keys will not be persistent on your vm. To add them select the Metadata section under Compute Engine and then Select the SSH Keys tab to add your key.</p>\n<p><img src=\"https://miro.medium.com/max/1052/1*6tXnjOHirPfeQSzgMXTLKA.png\" alt=\"alt text\" title=\"Metadata Page\"></p>\n<p>Now I’m going to hop over to our pi and configure AutoSSH.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo apt-get install autossh</span></span></code></pre>\n<p>Once we have this finished we need to ensure we can ssh over to our cloud instance from our pi with the key we generated. If this is not working, troubleshoot and come back. I know I had some spacing issues the first time adding the key to the metadata section.</p>\n<p>Once ssh works we need to test autossh via command line. The command and options I used are:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ autossh -M 0 -o &quot;ServerAliveInterval 30&quot; -o &quot;ServerAliveCountMax 3&quot; -R 10000:localhost:10000 user@instance -f -T -Nautossh -M 0 -o &quot;ServerAliveInterval 30&quot; -o &quot;ServerAliveCountMax 3&quot; -R 8080:localhost:80 user@instance -f -T -N</span></span></code></pre>\n<p>As you can see that is for forwarding my webmin port in the first command and the pihole port in second. We need to go over to our Google instance and verify ports are listening on localhost.</p>\n<p>I do this with:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo netstat -antp</span></span></code></pre>\n<p>I use sudo with those switches to see what process is running what. Anything outside your user will not show pid and process name.</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*9Q_A1wYjEbbLTvbFDKHWGA.png\" alt=\"alt text\" title=\"Netstat Output\"></p>\n<p>And we are working!! Now let’s make autossh into a service so our pi will connect and maintain that connection. Back to the Pi!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ cd /etc/systemd/system</span></span></code></pre>\n<p>Here we need to create two files for our two different autossh commands</p>\n<p>You can name them whatever you want but mine are autossh-pihole.service and autossh-webmin.service. I’m going to just show one and you can then make the changes you need for the second.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vi /etc/systemd/system/autossh-pihole.service</span></span></code></pre>\n<p>The contents of this file should look as follows:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">[Unit]\nDescription=AutoSSH tunnel service pihole\nAfter=network.target\n\n[Service]\nEnvironment=&quot;AUTOSSH_GAMETIME=2&quot;\nUser=pi\nExecStart=/usr/bin/autossh -M 0 -N -o &quot;ServerAliveInterval 30&quot; -o &quot;ServerAliveCountMax 3&quot; -p 22 -R 8080:localhost:80 user@instance -i /home/pi/.ssh/id_rsa\n\n[Install]\nWantedBy=multi-user.target</span></span></code></pre>\n<p>You can place your ssh key wherever you like and use whatever user you like. I HIGHLY recommend using a non-shell, non-privileged user you create. That way if anyone is able to obtain the key and hit your pi they aren’t able to do anything with it. The same on your Google Cloud Instance. Maybe add a user called autossh with no shell. Anyway, once we have this file, save it and quit. Then create the one for webmin. One both are complete…</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl daemon-reload\n$ sudo systemctl enable autossh-pihole.service\n$ sudo systemctl enable autossh-webmin.service\n$ sudo systemctl start autossh-pihole.service\n$ sudo systemctl start autossh-webmin.service</span></span></code></pre>\n<p>From here we verify services started ok with</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl status autossh-pihole.service \n$ sudo systemctl status autossh-webmin.service</span></span></code></pre>\n<p>If everything looks good we bounce back over to our Google Instance. First we verify that the ports are listening as expected. If so, we go to configuring NGINX!!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ cd /etc/nginx</span></span></code></pre>\n<p>We need to create two files for our webmin and pihole services in the sites-available folder. We need to make sure they match either our IP address or FQDN. If you want DNS resolution you need to add A records in your DNS for your domain. For example my domain is b34rd.tech. I added two A records. One for pihole and one for webmin. So my files in sites-available are webmin.b34rd.tech and pihole.b34rd.tech.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vim /etc/nginx/sites-available/webmin.b34rd.tech</span></span></code></pre>\n<p>In here we need to add the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">server {\n    server_name webmin.yourdoain.com;\n    listen 80;    location / {\n        proxy_pass http://127.0.0.1:10000;\n    }\n}</span></span></code></pre>\n<p>For pihole we do similar:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo vim /etc/nginx/sites-available/pihole.b34rd.techserver {\n    server_name pihole.yourdomain.com;\n    listen 80;    location / {\n        return 301 http://$host$request_uri/admin;\n    }    location /admin {\n        proxy_pass http://127.0.0.1:8080;\n    }\n}</span></span></code></pre>\n<p>No, we still don’t have SSL configured. BUT we can verify connectivity here.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo ln -s /etc/nginx/sites-available/pihole.b34rd.tech /etc/nginx/sites-enabled/$ sudo ln -s /etc/nginx/sites-available/webmin.b34rd.tech /etc/nginx/sites-enabled/$ sudo nginx -t</span></span></code></pre>\n<p>If you don’t receive output like this:</p>\n<p><img src=\"https://miro.medium.com/max/1400/1*mq96ywg5v_Dw27YBKd9wNQ.png\" alt=\"alt text\" title=\"Nginx Verification\"></p>\n<p>You need to verify syntax in your files.</p>\n<p>Let’s start up nginx!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl enable nginx$ sudo systemctl start nginx</span></span></code></pre>\n<p>Here we can browse to our cloud instance IP or our FQDN. We will be able to access our applications!</p>\n<p>Now we need to secure them. Luckily with certbot this is simple!</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo certbot --nginx -d pihole.yourdomain.com -d webmin.yourdomain.com</span></span></code></pre>\n<p>There will be on-screen prompts showing you status. Answer questions and select YES on redirect all to https. This will edit our config files for us to include all valid SSL certificates. We can restart nginx and verify this once again.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl restart nginx</span></span></code></pre>\n<p>If we are able to browse, are redirected to https we are almost done. We have one final step! Remember when I said we need some files from our CA. Here’s where they come in.</p>\n<p>We need to copy the following from our CA to our Cloud Instance:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">ca.crl\nca.crt</span></span></code></pre>\n<p>I put these files in the following locations:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">/etc/ssl/client/ca.crt\n/etc/ssl/client/ca.crl</span></span></code></pre>\n<p>You can put them anywhere you like but make sure you remember where you put them. We also need to copy the USER.p12 we created to our client machine. Whether that is a PC, Laptop, or Mobile we will need it.</p>\n<p>Final edit. In our sites-available in nginx we need to add the following:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\"># Client Cert Config\nssl_client_certificate /etc/ssl/client/ca.crt;\nssl_crl /etc/ssl/client/ca.crl;\nssl_verify_client on;</span></span></code></pre>\n<p>I personally add this to the first server section in the files. My pihole config looks like this now:</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">server {\n    server_name pihole.yourdomain.com;location / {\n        return 301 http://$host$request_uri/admin;\n    }location /admin {\n        proxy_pass http://127.0.0.1:8080;\n    }listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/pihole.yourdomain.com\n    /fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/pihole.yourdomain.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot# Client Cert config\n    ssl_client_certificate /etc/ssl/client/ca.crt;\n    ssl_crl /etc/ssl/client/ca.crl;\n    ssl_verify_client on;}\nserver {\n    if ($host = pihole.yourdomain.com) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbotlisten 80;\n    server_name pihole.b34rd.tech;\n    return 404; # managed by Certbot}</span></span></code></pre>\n<p>You will need to ensure you add this to your webmin file also and restart nginx one final time.</p>\n<pre class=\"shiki\" style=\"background-color: #ffffff\"><code><span class=\"line\"><span style=\"color: #24292eff\">$ sudo systemctl restart nginx </span></span></code></pre>\n<p>Now browse to your applications same as before. You will receive an error. Import your .p12 file into your client and browse again.</p>\n<p>BAM! Certificate authentication for your applications!!</p>\n<p>Future considerations..</p>\n<p>So, as I said earlier using specific users for autossh is super important. That is the first thing I would suggest doing if you didn’t already do so.</p>\n<p>Second, make nginx not disclose so much information. Setup custom error pages.</p>\n<p>Third, add some CSRF and other security features in nginx.</p>\n<p>Of course maintain patches and follow hardening guides for your pi and your cloud instance as well as nginx, lighttpd, and webmin.</p>\n<p>Also, add some IDS/IPS tools to your cloud instance. At least install Fail2Ban</p>\n","description":"Setup Raspberry Pi with pi-hole, squid, and cert authentication","timeToRead":18,"cover":"https://pi-hole.net/wp-content/uploads/2016/12/pihole-main.png","author":{"id":"b34rd","title":"b34rd","path":"/author/b34rd/"},"tags":[{"id":"raspberry pi","title":"raspberry pi","path":"/tag/raspberry%20pi/"},{"id":"pihole","title":"pihole","path":"/tag/pihole/"},{"id":"squid","title":"squid","path":"/tag/squid/"},{"id":"openssl","title":"openssl","path":"/tag/openssl/"}]}},"context":{}}